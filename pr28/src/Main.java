//Практика #1:
//
//	1.	@Override
//	•	Зачем нужна: Аннотация @Override используется для явного указания, что метод в подклассе переопределяет
//	метод суперкласса. Она помогает избежать ошибок, например, если метод в подклассе не соответствует сигнатуре метода
//	в суперклассе (например, неправильно указан тип или количество параметров).
//        •	Пример:
/*
class Parent {
    void display() {
        System.out.println("Parent display");
    }
}

class Child extends Parent {
    @Override
    void display() {
        System.out.println("Child display");
    }
}*/

//В этом примере метод display в классе Child переопределяет метод из класса Parent.
// Аннотация @Override гарантирует, что метод действительно переопределяет метод суперкласса.
//
//	2.	@Deprecated
//	•	Зачем нужна: Аннотация @Deprecated используется для обозначения методов, классов или полей,
//	которые больше не должны использоваться, так как они могут быть устаревшими и заменены более новыми решениями.
//	При использовании такого элемента компилятор будет предупреждать разработчика о том, что он использует устаревший код.
//        •	Пример:
/*
class MyClass {
    @Deprecated
    void oldMethod() {
        System.out.println("This method is deprecated.");
    }

    void newMethod() {
        System.out.println("This is the recommended method.");
    }
}*/

//В этом примере метод oldMethod помечен как устаревший, и при его вызове компилятор будет предупреждать
// о том, что этот метод больше не рекомендуется к использованию.
//
//	3.	@SuppressWarnings
//	•	Зачем нужна: Аннотация @SuppressWarnings используется для подавления предупреждений компилятора.
//	Это полезно, например, когда компилятор выдает предупреждения, которые в данном контексте не важны или не могут быть устранены.
//	•	Пример:
/*
@SuppressWarnings("unchecked")
public void myMethod() {
    List list = new ArrayList(); // компилятор будет предупреждать о необработанном типе
    list.add("Hello");
}*/

//В этом примере используется аннотация @SuppressWarnings("unchecked"), чтобы подавить предупреждения компилятора,
// связанные с использованием необработанных типов (raw types).
//
//Практика #2: Создание собственной аннотации
//
//Создание аннотации BaseAction и ее использование:
/*

@Target(ElementType.TYPE) // Ограничение аннотации на типы (например, классы)
public @interface BaseAction {
    int level(); // Метод-член для указания уровня
}

@BaseAction(level=2) // Применение аннотации с параметром level
public class Base {
    public void doAction() {
        // Получение аннотации класса Base
        Class clazz = Base.class;
        BaseAction action = clazz.getAnnotation(BaseAction.class);
        System.out.println(action.level()); // Вывод значения параметра level
    }
}
*/

//	•	Объяснение:
//        •	Аннотация BaseAction может быть применена к типам (например, к классам),
//        как указано в @Target(ElementType.TYPE).
//        •	В аннотации есть один метод-член level(), который должен быть задан при использовании аннотации.
//        •	В классе Base применяется аннотация @BaseAction(level=2), и метод doAction получает аннотацию с помощью
//        метода getAnnotation, чтобы извлечь значение параметра level() и вывести его.
//
//Этот код позволяет использовать аннотации для добавления метаданных к классам и их последующего анализа во время
// выполнения программы.