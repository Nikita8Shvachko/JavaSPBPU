class A {
    public static void method() {
        System.out.println("Метод из класса A");
    }
}

class B extends A {
    public static void method() {
        System.out.println("Метод из класса B");
    }
}

public class Main {
    public static void main(String[] args) {
        A a = new B();
        a.method();  // Вызовет метод из класса A, а не B, потому что это статический метод
    }
}
//Статические методы привязаны к классу, а не к объекту. Статические методы вызываются через имя класса,
// а не через экземпляр класса.


//Решение о вызове метода происходит на этапе компиляции. Для статических методов компилятор уже знает,
// какой метод будет вызван, потому что статические методы привязываются к классу на этапе компиляции

//В этом примере, несмотря на то, что объект a ссылается на экземпляр класса B, вызов метода method() ссылается на метод
// класса A, так как статический метод привязан к классу, а не к объекту. Следовательно, это не динамический полиморфизм, а компиляция по имени класса.